pragma solidity ^0.5.11;

// user sells diamonds
// setup scenario
// invalid diamond who does what
// TODO: simple setup scenario
// TODO: custodian adds diamond wrong this is how we correnct ir
// TODO: upgrade asm or dex functionality
// TODO: scenario, when theft is at custodian, how to recover from it, make a testcase of how to zero his collateral, and what to do with dpass tokens, dcdc tokens of him
// TODO: test for each basic use-case to demonstrate usability

// TODO: quickly growing new custodian gets too much CDC value and others no money for their purchase

// TODO: user puts his dpass for sale.
// TODO: oracle update CDC price must set cdc values as well
// DODO: lazy custodian looses money because prices went up and has less cdc from sale

import "ds-test/test.sol";
import "ds-auth/auth.sol";
import "ds-math/math.sol";
import "ds-token/token.sol";
import "ds-guard/guard.sol";
import "cdc-token/Cdc.sol";
import "dpass/Dpass.sol";
import "medianizer/medianizer.sol";
import "price-feed/price-feed.sol";
import "./DiamondExchange.sol";
import "./Burner.sol";
import "./Wallet.sol";
import "./SimpleAssetManagement.sol";
import "./Liquidity.sol";

contract IntegrationsTest {

    function setUp() public {
        _createContrats();
        _createActors();
        _createTokens();
        _setupGuard();
    }
    
    function test1MintCdcInt() public {

        _prepareTestMintCdcInt();
        
        dpass.setCccc("BR,IF,D,5.00", true);        // enable a cccc value diamonds can have only cccc values that are enabled first

        TestActor(custodian).doMintDpass(           // custodian must mint dpass first to create collateral for CDC
            dpass,                                  // token to mint (system can handle any number of different dpass tokens)
            custodian,                              // custodian of diamond, custodians can only set themselves no others
            "GIA",                                  // the issuer of following ID, currently GIA" is the only supported
            "2134567890",                           // GIA number (ID)
            "sale",                                 // if wants to have it for sale, if not then "valid"
            "BR,IF,D,5.00",                         // cut, clarity, color, weight range(start) of diamond
            511,                                    // carat is decimal 2 precision, so this diamond is 5.11 carats
            "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
                                                    // attribute hasn of all the attributes we stori
            "20191107",
            2928.03 ether                           // the price is 2928.03 USD for the diamond (not per carat!!!!)
                                        );
        asm.mint(cdc, user, 1 ether);               // mint 1 CDC token to user
    }

    function _prepareTestMintCdcInt() internal {
        uint cdcUsdRate = 100 ether;
        uint ethUsdRate = 100 ether;
        Medianizer cdcFeed = new Medianizer();                                          // create medianizer that calculates single price from multiple price sources
        
        PriceFeed cdcPriceOracle0 = new PriceFeed();                                    // oracle is a single price source that receives price data from several sources
        PriceFeed cdcPriceOracle1 = new PriceFeed();                                    // cdc price is updated every once a week
        PriceFeed cdcPriceOracle2 = new PriceFeed();

        cdcFeed.set(cdcPriceOracle0);                                                   // add oracle to medianizer to get price data from
        cdcFeed.set(cdcPriceOracle1);
        cdcFeed.set(cdcPriceOracle2);

        //--------------------oracles-update-price-data--------------------------------begin
        cdcPriceOracle0.poke(                                                           // oracle update cdc price every once a week
            cdcUsdRate,
            60 * 60 * 24 * 8                                                            // the data is valid for 8 days
        );

        cdcPriceOracle1.poke(                                                           // oracle update cdc price every once a week
            cdcUsdRate,
            60 * 60 * 24 * 8                                                            // the data is valid for 8 days
        );

        cdcPriceOracle1.poke(                                                           // oracle update cdc price every once a week
            cdcUsdRate,
            60 * 60 * 24 * 8                                                            // the data is valid for 8 days
        );
        //--------------------oracles-update-price-data--------------------------------end

        Medianizer ethFeed = new Medianizer();

        PriceFeed ethPriceOracle0 = new PriceFeed();                                    // oracle is a single price source that receives price data from several sources
        PriceFeed ethPriceOracle1 = new PriceFeed();                                    // eth price is updated every time the price changes more than 2%
        PriceFeed ethPriceOracle2 = new PriceFeed();

        ethFeed.set(ethPriceOracle0);                                                   // add oracle to medianizer to get price data from
        ethFeed.set(ethPriceOracle1);
        ethFeed.set(ethPriceOracle2);

        //--------------------oracles-update-price-data--------------------------------begin
        ethPriceOracle0.poke(                                                           // oracle update eth price every once a week
            ethUsdRate,
            60 * 60 * 24 * 8                                                            // the data is valid for 8 days
        );

        ethPriceOracle1.poke(                                                           // oracle update eth price every once a week
            ethUsdRate,
            60 * 60 * 24 * 8                                                            // the data is valid for 8 days
        );

        ethPriceOracle1.poke(                                                           // oracle update eth price every once a week
            ethUsdRate,
            60 * 60 * 24 * 8                                                            // the data is valid for 8 days
        );
        //--------------------oracles-update-price-data--------------------------------end

        DiamondExchange(exchange).setConfig("canSellErc20", b(cdc), b(true));           // user can sell cdc tokens
        DiamondExchange(exchange).setConfig("canBuyErc20", b(cdc), b(true));            // user can buy cdc tokens
        DiamondExchange(exchange).setConfig("decimals", b(cdc), b(18));                 // decimal precision of cdc tokens is 18
        DiamondExchange(exchange).setConfig("priceFeed", b(cdc), b(cdcFeed));           // priceFeed address is set
        DiamondExchange(exchange).setConfig("handledByAsm", b(cdc), b(true));           // make sure that cdc is minted by asset management
        DiamondExchange(exchange).setConfig(b("rate"), b(cdc), b(uint(cdcUsdRate)));     // rate of token in base currency (since Medianizer will return false, this value will be used)
        DiamondExchange(exchange).setConfig(b("manualRate"), b(cdc), b(true));          // allow using manually set prices on cdc token
        
        DiamondExchange(exchange).setConfig("canSellErc20", b(eth), b(true));           // user can sell eth tokens
        // DiamondExchange(exchange).setConfig("canBuyErc20", b(eth), b(true));         // user CAN NOT BUY ETH ON THIS EXCHANAGE
        DiamondExchange(exchange).setConfig("decimals", b(eth), b(18));                 // decimal precision of eth tokens is 18
        DiamondExchange(exchange).setConfig("priceFeed", b(eth), b(ethFeed));           // priceFeed address is set
        DiamondExchange(exchange).setConfig("handledByAsm", b(eth), b(true));           // make sure that eth is minted by asset management
        DiamondExchange(exchange).setConfig(b("rate"), b(eth), b(uint(ethUsdRate)));      // rate of token in base currency (since Medianizer will return false, this value will be used)
        DiamondExchange(exchange).setConfig(b("manualRate"), b(eth), b(true));          // allow using manually set prices on eth token

        DiamondExchange(exchange).setConfig("liq", b(liq), b(""));                      // set liquidity contract
        DiamondExchange(exchange).setConfig("burner", b(burner), b(""));                // set burner contract to burn profit of dpt owners
        DiamondExchange(exchange).setConfig("asm", b(asm), b(""));                      // set asset management contract
        DiamondExchange(exchange).setConfig("wal", b(wal), b(""));                      // set wallet to store cost part of fee received from users

        DiamondExchange(exchange).setConfig("fixFee", b(0 ether), b(""));               // fixed part of fee that is independent of purchase value
        DiamondExchange(exchange).setConfig("varFee", b(0.04 ether), b(""));            // percentage value defining how much of purchase value if paid as fee value between 0 - 1 ether
        DiamondExchange(exchange).setConfig("profitRate", b(0.1 ether), b(""));         // percentage value telling how much of total fee goes to profit of DPT owners 
        DiamondExchange(exchange).setConfig(b("takeProfitOnlyInDpt"), b(b32(true)), b("")); // if set true only profit part of fee is withdrawn from user in DPT, if false the total fee will be taken from user in DPT

        //-------------setup-asm------------------------------------------------------------

        SimpleAssetManagement(asm).setConfig("priceFeed", b(cdc), b(cdcFeed), "diamonds");          // set price feed (sam as for exchange)
        SimpleAssetManagement(asm).setConfig("manualRate", b(cdc), b(true), "diamonds");            // enable to use rate that is not coming from feed
        SimpleAssetManagement(asm).setConfig("decimals", b(cdc), b(18), "diamonds");                // set precision of token to 18
        SimpleAssetManagement(asm).setConfig("payTokens", b(cdc), b(true), "diamonds");             // allow cdc to be used as means of payment for services
        SimpleAssetManagement(asm).setConfig("cdcs", b(cdc), b(true), "diamonds");                  // tell asm that cdc is indeed a cdc token
        SimpleAssetManagement(asm).setConfig("rate", b(cdc), b(cdcUsdRate), "diamonds");            // set rate for token

        SimpleAssetManagement(asm).setConfig("priceFeed", b(eth), b(ethFeed), "diamonds");          // set pricefeed for eth
        SimpleAssetManagement(asm).setConfig("payTokens", b(eth), b(true), "diamonds");             // enable eth to pay with
        SimpleAssetManagement(asm).setConfig("manualRate", b(eth), b(true), "diamonds");            // enable to set rate of eth manually if feed is dowh (as is current situations)
        SimpleAssetManagement(asm).setConfig("decimals", b(eth), b(18), "diamonds");                // set precision for eth token
        SimpleAssetManagement(asm).setConfig("rate", b(eth), b(ethUsdRate), "diamonds");            // set USD(base currency) rate of token ( this is the price of token in USD)

        SimpleAssetManagement(asm).setConfig("overCollRatio", b(1.1 ether), "", "diamonds");        // make sure that the value of dpass + dcdc tokens is at least 1.1 times the value of cdc tokens.
        SimpleAssetManagement(asm).setConfig("setApproveForAll", b(dpass), b(exchange), b(true));   // enable the dpass tokens of asm to be handled by dex
        SimpleAssetManagement(asm).setConfig("custodians", b(custodian), b(true), "diamonds");      // setup the custodian
    } 

    function _createContracts() internal {
        burner = address(uint160(address(new Burner(DSToken(dpt))))); // Burner()   // burner contract
        wal = address(uint160(address(new Wallet()))); // DptTester()               // wallet contract
        uint ourGas = gasleft();
        asm = address(uint160(address(new SimpleAssetManagement())));               // asset management contract
        emit LogTest("cerate SimpleAssetManagement");
        emit LogTest(ourGas - gasleft());

        ourGas = gasleft();
        emit LogTest("cerate DiamondExchange");
        exchange = address(uint160(address(new DiamondExchange())));
        emit LogTest(ourGas - gasleft());

        liq = address(uint160(address(new Liquidity())));                           // DPT liquidity pprovider contract 
        DSToken(dpt).transfer(liquidityContract, INITIAL_BALANCE);
        DiamondExchangeTester(liquidityContract).approve(dpt, exchange, uint(-1));

        fca = address(uint160(address(new FeeCalculator())));                       // fee calculation contract 
    }

    function _createActors() internal {
        user = address(new TesterActor(address(asm)));
        user1 = address(new TesterActor(address(asm)));
        custodian = address(new TesterActor(address(asm)));
        custodian1 = address(new TesterActor(address(asm)));
        custodian2 = address(new TesterActor(address(asm)));
    }

    function _createTokens() internal {
        dpt = address(new DSToken("DPT"));
        dai = address(new DSToken("DAI"));
        eth = address(0xee);
        eng = address(new DSToken("ENG"));   // TODO: make sure it is 8 decimals

        cdc = address(new Cdc("BR,VS,G,0.05", "CDC"));
        // TODO: change to Cdc() from DSToken() below
        cdc1 = address(new Cdc("BR,VS,F,1.00", "CDC1"));
        cdc2 = address(new Cdc("BR,VS,E,2.00", "CDC2"));

        dcdc = address(new Dcdc("BR,VS,G,0.05", "DCDC", true));
        dcdc1 = address(new Dcdc("BR,SI3,E,0.04", "DCDC1", true));
        dcdc2 = address(new Dcdc("BR,SI1,F,1.50", "DCDC2", true));

        dpass = address(new Dpass());
        dpass1 = address(new Dpass());
        dpass2 = address(new Dpass());
    }

    function _setupGuard() internal {
        guard = new DSGuard();
        SimpleAssetManagement(burner).setAuthority(guard);
        SimpleAssetManagement(wal).setAuthority(guard);
        SimpleAssetManagement(asm).setAuthority(guard);
        SimpleAssetManagement(exchange).setAuthority(guard);
        SimpleAssetManagement(liq).setAuthority(guard);
        SimpleAssetManagement(fca).setAuthority(guard);
        DSToken(dpt).setAuthority(guard);
        DSToken(dai).setAuthority(guard);
        DSToken(eth).setAuthority(guard);
        DSToken(eng).setAuthority(guard);
        DSToken(cdc).setAuthority(guard);
        DSToken(cdc1).setAuthority(guard);
        DSToken(cdc2).setAuthority(guard);
        DSToken(dcdc).setAuthority(guard);
        DSToken(dcdc1).setAuthority(guard);
        DSToken(dcdc2).setAuthority(guard);
        DSToken(dpass).setAuthority(guard);
        DSToken(dpass1).setAuthority(guard);
        DSToken(dpass2).setAuthority(guard);
        guard.permit(address(this), address(asm), ANY);
        guard.permit(address(asm), cdc, ANY);
        guard.permit(address(asm), cdc1, ANY);
        guard.permit(address(asm), cdc2, ANY);
        guard.permit(address(asm), dpass, ANY);
        guard.permit(address(asm), dpass1, ANY);
        guard.permit(address(asm), dpass2, ANY);
        guard.permit(exchange, asm, ANY);
        guard.permit(exchange, liq, ANY);
    } 


}
//----------------end-of-IntegrationsTest--------------------------------------------
contract TesterActor is TrustedSASMTester, DiamondExchangeTester {
    constructor(
        address payable exchange_,
        address payable asm_
    ) public TrustedSASMTester(asm_) DiamondExchangeTester(exchange_) {}
}
contract TrustedSASMTester is Wallet {
    SimpleAssetManagement asm;

    constructor(address payable asm_) public {
        asm = SimpleAssetManagement(asm_);
    }

    function doSetConfig(bytes32 what_, bytes32 value_, bytes32 value1_, bytes32 value2_) public {
        asm.setConfig(what_, value_, value1_, value2_);
    }

    function doSetBasePrice(address token, uint256 tokenId, uint256 price) public {
        asm.setBasePrice(token, tokenId, price);
    }

    function doUpdateCdcValue(address cdc) public {
        asm.updateCdcValue(cdc);
    }

    function doUpdateTotalDcdcValue(address dcdc) public {
        asm.updateTotalDcdcValue(dcdc);
    }

    function doUpdateDcdcValue(address dcdc, address custodian) public {
        asm.updateDcdcValue(dcdc, custodian);
    }

    function doNotifyTransferFrom(address token, address src, address dst, uint256 amtOrId) public {
        asm.notifyTransferFrom(token, src, dst, amtOrId);
    }

    function doBurn(address token, uint256 amt) public {
        asm.burn(token, amt);
    }

    function doMint(address token, address dst, uint256 amt) public {
        asm.mint(token, dst, amt);
    }

    function doMintDpass(
        address token_,
        address custodian_,
        bytes32 issuer_,
        bytes32 report_,
        bytes32 state_,
        bytes32 cccc_,
        uint24 carat_,
        bytes32 attributesHash_,
        bytes8 currentHashingAlgorithm_,
        uint price_
    ) public returns (uint) {

        return asm.mintDpass(
            token_,
            custodian_,
            issuer_,
            report_,
            state_,
            cccc_,
            carat_,
            attributesHash_,
            currentHashingAlgorithm_,
            price_);
    }

    function doMintDcdc(address token, address dst, uint256 amt) public {
        asm.mintDcdc(token, dst, amt);
    }

    function doBurnDcdc(address token, address dst, uint256 amt) public {
        asm.burnDcdc(token, dst, amt);
    }

    function doWithdraw(address token, uint256 amt) public {
        asm.withdraw(token, amt);
    }

    function doUpdateCollateralDpass(uint positiveV, uint negativeV, address custodian) public {
        asm.updateCollateralDpass(positiveV, negativeV, custodian);
    }

    function doUpdateCollateralDcdc(uint positiveV, uint negativeV, address custodian) public {
        asm.updateCollateralDcdc(positiveV, negativeV, custodian);
    }

    function doApprove(address token, address dst, uint256 amt) public {
        DSToken(token).approve(dst, amt);
    }

    function doSendToken(address token, address src, address payable dst, uint256 amt) public {
        sendToken(token, src, dst, amt);
    }

    function doSendDpassToken(address token, address src, address payable dst, uint256 id_) public {
        Dpass(token).transferFrom(src, dst, id_);
    }

    function () external payable {
    }
}



contract DiamondExchangeTester is Wallet, DSTest {
    // TODO: remove all following LogTest()
    event LogTest(uint256 what);
    event LogTest(bool what);
    event LogTest(address what);
    event LogTest(bytes32 what);

    DiamondExchange public exchange;


    constructor(address payable exchange_) public {
        require(exchange_ != address(0), "CET: exchange 0x0 invalid");
        exchange = DiamondExchange(exchange_);
    }

    function () external payable {
    }

    function doApprove(address token, address to, uint amount) public {
        require(token != address(0), "Can't approve token of 0x0");
        require(to != address(0), "Can't approve address of 0x0");
        DSToken(token).approve(to, amount);
    }

    function doApprove721(address token, address to, uint amount) public {
        require(token != address(0), "Can't approve token of 0x0");
        require(to != address(0), "Can't approve address of 0x0");
        Dpass(token).approve(to, amount);
    }

    function doTransfer(address token, address to, uint amount) public {
        DSToken(token).transfer(to, amount);
    }

    function doTransferFrom(address token, address from, address to, uint amount) public {
        DSToken(token).transferFrom(from, to, amount);
    }

    function doTransfer721(address token, address to, uint id) public {
        Dpass(token).transferFrom(address(this), to, id);
    }

    function doTransferFrom721(address token, address from, address to, uint amount) public {
        Dpass(token).transferFrom(from, to, amount);
    }

    function doSetBuyPrice(address token, uint256 tokenId, uint256 price) public {
        DiamondExchange(exchange).setBuyPrice(token, tokenId, price);
    }

    function doGetBuyPrice(address token, uint256 tokenId) public view returns(uint256) {
        return DiamondExchange(exchange).getBuyPrice(token, tokenId);
    }

    function doBuyTokensWithFee(
        address sellToken,
        uint256 sellAmtOrId,
        address buyToken,
        uint256 buyAmtOrId
    ) public payable logs_gas {
        if (sellToken == address(0xee)) {

            DiamondExchange(exchange)
            .buyTokensWithFee
            .value(sellAmtOrId == uint(-1) ? address(this).balance : sellAmtOrId > address(this).balance ? address(this).balance : sellAmtOrId)
            (sellToken, sellAmtOrId, buyToken, buyAmtOrId);

        } else {

            DiamondExchange(exchange).buyTokensWithFee(sellToken, sellAmtOrId, buyToken, buyAmtOrId);
        }
    }

    function doSetConfig(bytes32 what, address value_, address value1_) public { doSetConfig(what, b32(value_), b32(value1_)); }
    function doSetConfig(bytes32 what, address value_, bytes32 value1_) public { doSetConfig(what, b32(value_), value1_); }
    function doSetConfig(bytes32 what, address value_, uint256 value1_) public { doSetConfig(what, b32(value_), b32(value1_)); }
    function doSetConfig(bytes32 what, address value_, bool value1_) public { doSetConfig(what, b32(value_), b32(value1_)); }
    function doSetConfig(bytes32 what, uint256 value_, address value1_) public { doSetConfig(what, b32(value_), b32(value1_)); }
    function doSetConfig(bytes32 what, uint256 value_, bytes32 value1_) public { doSetConfig(what, b32(value_), value1_); }
    function doSetConfig(bytes32 what, uint256 value_, uint256 value1_) public { doSetConfig(what, b32(value_), b32(value1_)); }
    function doSetConfig(bytes32 what, uint256 value_, bool value1_) public { doSetConfig(what, b32(value_), b32(value1_)); }

    function doSetConfig(bytes32 what_, bytes32 value_, bytes32 value1_) public {
        DiamondExchange(exchange).setConfig(what_, value_, value1_);
    }

    function doGetDecimals(address token_) public view returns(uint8) {
        return DiamondExchange(exchange).getDecimals(token_);
    }

    /**
    * @dev Convert address to bytes32
    * @param a address that is converted to bytes32
    * @return bytes32 conversion of address
    */
    function b32(address a) public pure returns (bytes32) {
        return bytes32(uint256(a));
    }

    /**
    * @dev Convert uint256 to bytes32
    * @param a uint value to be converted
    * @return bytes32 converted value
    */
    function b32(uint a) public pure returns (bytes32) {
        return bytes32(a);
    }

    /**
    * @dev Convert uint256 to bytes32
    * @param a_ bool value to be converted
    * @return bytes32 converted value
    */
    function b32(bool a_) public pure returns (bytes32) {
        return bytes32(uint256(a_ ? 1 : 0));
    }

    /**
    * @dev Convert address to bytes32
    */
    function addr(bytes32 b) public pure returns (address) {
        return address(uint160(uint256(b)));
    }

    function doCalculateFee(
        address sender_,
        uint256 value_,
        address sellToken_,
        uint256 sellAmtOrId_,
        address buyToken_,
        uint256 buyAmtOrId_
    ) public view returns (uint256) {
        return DiamondExchange(exchange).calculateFee(sender_, value_, sellToken_, sellAmtOrId_, buyToken_, buyAmtOrId_);
    }

    function doGetRate(address token_) public view returns (uint rate_) {
        return DiamondExchange(exchange).getRate(token_);
    }

    function doGetLocalRate(address token_) public view returns (uint rate_) {
        return DiamondExchange(exchange).getRate(token_);
    }

}

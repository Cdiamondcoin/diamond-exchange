pragma solidity ^0.5.11;

import "ds-test/test.sol";
import "ds-math/math.sol";
import "ds-token/token.sol";
import "dpass/Dpass.sol";
import "./Wallet.sol";

contract TokenUser {
    Wallet wal;

    constructor(address payable _wal) public {
        wal = Wallet(_wal);
    }

    function doTransferWallet(address token, address payable dst, uint256 amt) public returns (bool) {
        return wal.transfer(token, dst, amt);
    }

    function doTransferFromWallet(address token, address src, address payable dst, uint256 amt) public returns (bool) {
        return wal.transferFrom(token, src, dst, amt);
    }

    function doTotalSupplyWallet(address token) public view returns (uint) {
        return wal.totalSupply(token);
    }

    function doBalanceOfWallet(address token, address src) public view returns (uint) {
        return wal.balanceOf(token, src);
    }

    function doAllowanceWallet(address token, address src, address guy) public view returns (uint) {
        return wal.allowance(token, src, guy);
    }

    function doApproveWallet(address token, address guy, uint wad) public {
        wal.approve(token, guy, wad);
    }

    function doTransferToken(address token, address payable dst, uint256 amt) public returns (bool) {
        return DSToken(token).transfer(dst, amt);
    }

    function doTransferFromToken(address token, address src, address payable dst, uint256 amt) public returns (bool) {
        return DSToken(token).transferFrom(src, dst, amt);
    }

    function doTotalSupplyToken(address token) public view returns (uint) {
        return DSToken(token).totalSupply();
    }

    function doBalanceOfToken(address token, address src) public view returns (uint) {
        return DSToken(token).balanceOf(src);
    }

    function doAllowanceToken(address token, address src, address guy) public view returns (uint) {
        return DSToken(token).allowance(src, guy);
    }

    function doApproveToken(address token, address guy, uint wad) public {
        DSToken(token).approve(guy, wad);
    }

    function () external payable {}
}


contract WalletTest is DSTest, DSMath {
    // TODO: remove all following LogTest()
    event LogTest(uint256 what);
    event LogTest(bool what);
    event LogTest(address what);
    event LogTest(bytes32 what);

    mapping(address => uint) dpassId;
    uint constant initialBalance = 1000;
    DSToken dpt;
    address eth;
    Dpass dpass;
    TokenUser user;
    address payable userAddr;
    Wallet wal;
    address payable walAddr;
    address self;
    uint initEth;
    uint initDpt;
    bool showActualExpected;

    function setUp() public {
        dpt = new DSToken("DPT");
        wal = new Wallet();
        dpass = new Dpass();
        walAddr = address(uint160(address(wal)));
        eth = address(0xee);
        user = new TokenUser(walAddr);
        seller = new TokenUser(walAddr);
        userAddr = address(uint160(address(user)));
        self = address(this);

        dpt.mint(initialBalance * 1000);

        dpt.transfer(walAddr, initialBalance);
        dpt.transfer(userAddr, initialBalance);
        walAddr.transfer(initialBalance);
        userAddr.transfer(initialBalance);
        dpt.approve(userAddr, 100);
        initEth = address(this).balance;
        initDpt = dpt.balanceOf(address(this));

        Dpass(dpass).setCccc("BR,IF,F,0.01", true);
        dpassId[user] = Dpass(dpass).mintDiamondTo(
            user,                                                               // address _to,
            seller,                                                             // address _custodian
            "gia",                                                              // bytes32 _issuer,
            "2141438167",                                                       // bytes32 _report,
            "sale",                                                             // bytes32 _state,
            "BR,IF,F,0.01",
            0.2 * 100,
            bytes32(uint(0xc0a5d062e13f99c8f70d19dc7993c2f34020a7031c17f29ce2550315879006d7)), // bytes32 _attributesHash
            "20191101"
        );

        Dpass(dpass).setCccc("BP,IF,G,0.01", true);
        dpassId[wal] = Dpass(dpass).mintDiamondTo(
            user,                                                               // address _to,
            seller,                                                             // address _custodian
            "gia",                                                              // bytes32 _issuer,
            "22222222",                                                         // bytes32 _report,
            "sale",                                                             // bytes32 _state,
            "BR,IF,G,0.01",
            0.2 * 100,
            bytes32(uint(0xc0a5d062e13f99c8f70d19dc7993c2f34020a7031c17f29ce2550315879006d7)), // bytes32 _attributesHash
            "20191101"
        );

    }

    function () external payable {
    }

    function logMsgActualExpected(bytes32 logMsg, uint256 actual_, uint256 expected_, bool showActualExpected_) public {
        emit log_bytes32(logMsg);
        if(showActualExpected_ || showActualExpected) {
            emit log_bytes32("actual");
            emit LogTest(actual_);
            emit log_bytes32("expected");
            emit LogTest(expected_);
        }
    }
    function logMsgActualExpected(bytes32 logMsg, address actual_, address expected_, bool showActualExpected_) public {
        emit log_bytes32(logMsg);
        if(showActualExpected_ || showActualExpected) {
            emit log_bytes32("actual");
            emit LogTest(actual_);
            emit log_bytes32("expected");
            emit LogTest(expected_);
        }
    }

    function assertEqDustLog(bytes32 logMsg, uint256 actual_, uint256 expected_, address decimalToken) public {
        logMsgActualExpected(logMsg, actual_, expected_, !isEqualDust(actual_, expected_, decimalToken));
        assertEqDust(actual_, expected_, decimalToken);
    }

    function assertEqDustLog(bytes32 logMsg, uint256 actual_, uint256 expected_) public {
        logMsgActualExpected(logMsg, actual_, expected_, !isEqualDust(actual_, expected_));
        assertEqDust(actual_, expected_);
    }

    function assertEqLog(bytes32 logMsg, address actual_, address expected_) public {
        logMsgActualExpected(logMsg, actual_, expected_, false);
        assertEq(actual_, expected_);
    }

    function assertEqLog(bytes32 logMsg, uint256 actual_, uint256 expected_) public {
        logMsgActualExpected(logMsg, actual_, expected_, false);
        assertEq(actual_, expected_);
    }

    function assertNotEqualLog(bytes32 logMsg, address actual_, address expected_) public {
        logMsgActualExpected(logMsg, actual_, expected_, actual_ == expected_);
        assertTrue(actual_ != expected_);
    } 
    function testWalletTransferWallet() public {
        uint sentAmount = 250;
        wal.transfer(address(dpt), userAddr, sentAmount);
        assertEq(wal.balanceOf(address(dpt), userAddr), add(initialBalance, sentAmount));
        assertEq(wal.balanceOf(address(dpt), address(uint160(walAddr))), sub(initialBalance, sentAmount));
    }

    function testWalletTransferEthWallet() public {
        uint sentAmount = 250;
        wal.transfer(eth, userAddr, sentAmount);
        assertEq(userAddr.balance,  add(initialBalance, sentAmount));
        assertEq(walAddr.balance, sub(initialBalance, sentAmount));
    }

    function testWalletTransferFromWallet() public {
        uint sentAmount = 250;
        user.doApproveToken(address(dpt), walAddr, sentAmount);

        wal.transferFrom(address(dpt), userAddr, address(uint160(address(this))),  sentAmount);
        assertEq(
            wal.balanceOf(address(dpt), address(user)), 
            sub(initialBalance, sentAmount));
        assertEq(
            wal.balanceOf(address(dpt), address(uint160(address(this)))),
            add(initDpt, sentAmount));
    }

    function testWalletTotalSupplyWallet() public {
        uint totalSupply = wal.totalSupply(address(dpt));
        assertEq(totalSupply, initialBalance * 1000);
    }

    function testFailWalletTotalSupplyEthWallet() public view {
        wal.totalSupply(eth);
    }

    function testWalletBalanceOfWallet() public {
        assertEq(wal.balanceOf(address(dpt), userAddr), initialBalance);
    }

    function testWalletBalanceOfEthWallet() public {
        assertEq(wal.balanceOf(eth, userAddr), initialBalance);
    }

    function testWalletAllowanceWallet() public {
        assertEq(wal.allowance(address(dpt), address(this), userAddr), 100);
    }

    function testFailWalletAllowanceEthWallet() public view {
        wal.allowance(eth, address(this), userAddr);
    }

    function testWalletApproveWallet() public {        

        wal.approve(address(dpt), userAddr, 500);
        assertEq(wal.allowance(address(dpt), walAddr, userAddr), 500);

        user.doTransferFromToken(address(dpt), walAddr, userAddr, 500);
        
        assertEq(wal.balanceOf(address(dpt), userAddr), add(initialBalance, 500));
        assertEq(wal.balanceOf(address(dpt), walAddr), sub(initialBalance, 500));
    }

    function testFailWalletApproveWithoutAuthWallet() public {        
        wal.approve(address(dpt), userAddr, 500);
        user.doTransferFromToken(address(dpt), address(this), userAddr, 501);
    }

    function testFailWalletAboveApproveWallet() public {
        wal.approve(eth, userAddr, 500);
    }

    function testFailWalletTransferByUserWallet() public {
        user.doTransferWallet(address(dpt), userAddr, 500);
    }

    function testFailWalletTransferFromByUserWallet() public {
        wal.approve(address(dpt), userAddr, 500);
        user.doTransferFromWallet(address(dpt), walAddr, userAddr, 500);
    }

    function testFailWalletApproveByUserWallet() public {
        user.doApproveWallet(address(dpt), userAddr, 500);
    }

    function testWalletSetUserAsOwnerTransferByUserWallet() public {
        wal.setOwner(userAddr);
        user.doTransferWallet(address(dpt), userAddr, 500);
    }

    function testWalletSetUserAsOwnerTransferFromByUserWallet() public {
        wal.approve(address(dpt), userAddr, 500);
        wal.setOwner(userAddr);
        user.doTransferFromWallet(address(dpt), walAddr, userAddr, 500);
    }

    function testWalletSetUserAsOwnerApproveByUserWallet() public {
        wal.setOwner(userAddr);
        user.doApproveWallet(address(dpt), userAddr, 500);
    }

    function testBalanceOf721() public {
        assertEqLog("balanceOf() dpt user is 1", wal.balanceOf721(dpass, user), 1);
        assertEqLog("balanceOf() dpt wal is 1", wal.balanceOf721(dpass, wal), 1);
        wal.transfer721(dpass, user, dpassId[wal]);
        assertEqLog("balanceOf() dpt user is 2", wal.balanceOf721(dpass, user), 1);
        assertEqLog("balanceOf() dpt wal is 0", wal.balanceOf721(dpass, wal), 1);
    }

    function testOwnerOf721() public {
        assertEqLog("ownerOf() is user", wal.ownerOf721(dapss, dpassId[user]), user);
        assertEqLog("ownerOf() is wal", wal.ownerOf721(dapss, dpassId[wal]), wal);
        wal.transfer721(dpass, user, dpassId[wal]);
        assertEqLog("ownerOf() is user", wal.ownerOf721(dapss, dpassId[user]), user);
        assertEqLog("ownerOf() is user", wal.ownerOf721(dapss, dpassId[wal]), user);
    }

    function testApprove721() public {
        wal.approve721(dpass, user, dpassId[wal]);
        assertEqLog("user approved by wal", wal.getApproved(dpass, dpassId[wal]), user);
        
    }

    function testGetApproved721() public {
        wal.getApproved721(token, tokenId);
    }

    function testSetApprovalForAll721() public {
        wal.setApprovalForAll721(token, to, approved);
    }

    function testIsApprovedForAll721() public {
        wal.isApprovedForAll721(token, owner, operator);
    }

    function testTransferFrom721() public {
        wal.transferFrom721(token, from, to, tokenId);
    }

    function testSafeTransferFrom721() public {
        wal.safeTransferFrom721(token, from, to, tokenId);
    }

    function testSafeTransferFrom721() public {
        wal.safeTransferFrom721(token, from, to, tokenId, _data);
    }

    function testTransfer721() public {
        wal.transfer721(token, to, tokenId);
    }
    */
}

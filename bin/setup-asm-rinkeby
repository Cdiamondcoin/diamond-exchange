#!/usr/bin/env bash
set -x

## Settings for test networks like Rinkeby, Kovan, Ropsten

## Internal settings (do not touch these unless you know what you are doing!!)
export ETH_RPC_PORT=${ETH_RPC_PORT:-"8545"}
export ETH_RPC_URL=https://rinkeby.infura.io/v3/47706a887c1245319e35b5e507c7f097
export ETH_KEYSTORE="$(pwd)"
export ETH_GAS=8000000
export ETH_GAS_PRICE=20000000000
export ETH_FROM=0x9556E25F9b4D343ee38348b6Db8691d10fD08A61
export ETH_PASSWORD=~/.eth-pwd

# echo -e "===================== ######################## =========================="
# echo -e "=====================       Addresses          ==========================="
# echo -e "===================== ######################## =========================="
export custodian=0x9556E25F9b4D343ee38348b6Db8691d10fD08A61
export eth=0x00000000000000000000000000000000000000ee

# Deployed contrcts
export dpass=0x18a7a95d17f2e7208982922a814d49661f23a073

export dpt=0xe52649ed992f24ee90c3db78cc43a3bcc998e207
export cdc=0xa117bfbbfcb77043588ec47fe72baa4759a024f6
export ethPriceFeed=0x573585bd725a3b62ce5fd46240ca2233ff06face
export dptPriceFeed=0xb07250e4a3838fc1cc78e65027d0a10b43e11ff3
export cdcPriceFeed=0x8456c68f86b17e837355b16134130bb99c9f457a
export liq=0x8173937ecc0c11a8262bbaa8b92eea3a83b9c257
export wal=0x255fbb467368b48e814785d9947d47b55c37f1a3
export burner=0xef80bcfd7b21447d5ffefcfa8a9ae6fa60419868
export dcdc=0xf13f5580b26d11951d6e1f4b6af5f3c2e2ebc497
export guard=0x295128cdeb76633bb2dd6538b97d25d86c0d9719
export dex=0x5cb0f6255b0eb2e6140c65287ea98a7bb741ffb0
export asm=0x16f6afb964acf12697bdbf1fedf3987e457b3f83


# address to bytes32
function atb() {
    echo $(seth --to-bytes32 $(seth --to-uint256 $1))
}

# text to bytes32
function ttb() {
    echo $(seth --to-bytes32 $(seth --from-ascii $1))
}

# number to bytes32
function ntb() {
    echo $(seth --to-bytes32 $(seth --to-uint256 $1))
}

# eth to bytes32
function etb() {
    echo $(seth --to-bytes32 $(seth --to-uint256 $(seth --to-wei $1 eth)))
}

# eth to wei
function etw() {
    echo $(seth --to-wei $1 eth)
}

# wei to eth
function wte() {
    echo $(seth --from-wei $1)
}

# hex to bytes32
function htb() {
    echo $(seth --to-bytes32 $1)
}

# hex to uint256
function htu() {
    echo $(seth --to-uint256 $1)
}

function toKeccak () {
    echo $(seth keccak $1)
}

function sigTob () {
    echo $(seth --to-bytes32 $(seth sig $1))
}

export true=$(ntb 1)
export false=$(ntb 0)
export empty=$(ttb "")
export b18=$(ntb 18)

# export any=$(seth call $guard "ANY()")
export any="0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
export uAny=$(htu $any)
export bAny=$(htb $any)


#----------------------------------------setup-liquidity--------------------------------------------------------

seth send $liq "approve(address,address,uint)" $dpt $dex $uAny

#----------------------------------------setup-guard------------------------------------------------------------
seth send $burner "setAuthority(address)" $guard
seth send $wal "setAuthority(address)" $guard
seth send $asm "setAuthority(address)" $guard
seth send $dex "setAuthority(address)" $guard
seth send $liq "setAuthority(address)" $guard

seth send $dpt "setAuthority(address)" $guard
seth send $cdc "setAuthority(address)" $guard
seth send $dcdc "setAuthority(address)" $guard
seth send $dpass "setAuthority(address)" $guard

# caller, toContract, permissions
seth send $guard "permit(address,address,bytes32)" $asm $cdc $bAny
seth send $guard "permit(address,address,bytes32)" $asm $dpass $bAny
seth send $guard "permit(address,address,bytes32)" $dex $asm $bAny
seth send $guard "permit(address,address,bytes32)" $dex $liq $bAny

seth send $guard "permit(bytes32,bytes32,bytes32)" $bAny $(seth --to-bytes32 $dex) $(sigTob "getRate(address)")

# Permissions to custodian
# seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "getRate(address)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "getRateNewest(address)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "burn(address,address,uint256)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "mint(address,address,uint256)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "burnDcdc(address,address,uint256)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "mintDpass(address,address,bytes3,bytes16,bytes8,bytes20,uint24,bytes32,bytes8,uint256)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "mintDcdc(address,address,uint256)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "withdraw(address,uint256)")
seth send $guard "permit(address,address,bytes32)" $custodian $asm $(sigTob "setStateDpass(address,uint256,bytes8)")

seth send $guard "permit(address,address,bytes32)" $custodian $dpass $(sigTob "linkOldToNewToken(uint256,uint256)")
seth send $guard "permit(address,address,bytes32)" $custodian $dpass $(sigTob "mintDiamondTo(address,address,bytes32,bytes32,bytes32,bytes32,uint24,bytes32,bytes8)")


#----------------------------------------setup-dex------------------------------------------------------------
# user can sell cdc tokens
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb canSellErc20) $(atb $cdc) $true
# user can buy cdc tokens
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb canBuyErc20) $(atb $cdc) $true
# decimal precision of cdc tokens is 18
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb decimals) $(atb $cdc) $(ntb 18)
# priceFeed address is set
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb priceFeed) $(atb $cdc) $(atb $cdcPriceFeed)
# make sure that cdc is minted by asset management
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb handledByAsm) $(atb $cdc) $true
# rate of token in base currency (since Medianizer will return false, this value will be used)
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb rate) $(atb $cdc) $(etb 70)
# allow using manually set prices on cdc token
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb manualRate) $(atb $cdc) $true


# user can sell eth tokens
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb canSellErc20) $(atb $eth) $true
# user CAN NOT BUY ETH ON THIS EXCHANAGE
# seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb canBuyErc20) $(atb $cdc) $true
# decimal precision of eth tokens is 18
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb decimals) $(atb $eth) $(ntb 18)
# priceFeed address is set
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb priceFeed) $(atb $eth) $(atb $ethPriceFeed)
# eth SHOULD NEVER BE DECLARED AS handledByAsm, because it can not be minted
# seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb handledByAsm) $(atb $cdc) $true
# rate of token in base currency (since Medianizer will return false, this value will be used)
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb rate) $(atb $eth) $(etb 146)
# allow using manually set prices on eth token
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb manualRate) $(atb $eth) $true


# user can sell dpt tokens
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb canSellErc20) $(atb $dpt) $true
# decimal precision of dpt tokens is 18
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb decimals) $(atb $dpt) $(ntb 18)
# priceFeed address is set
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb priceFeed) $(atb $dpt) $(atb $dptPriceFeed)
# rate of token in base currency (since Medianizer will return false, this value will be used)
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb rate) $(atb $dpt) $(etb 12)
# allow using manually set prices on dpt token
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb manualRate) $(atb $dpt) $true


# tell exhcange which one is the DPT token
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb dpt) $(atb $dpt) $empty
# set liquidity contract
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb liq) $(atb $liq) $empty
# set burner contract to burn profit of dpt owners
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb burner) $(atb $burner) $empty
# set asset management contract
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb asm) $(atb $asm) $empty
# set wallet to store cost part of fee received from users
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb wal) $(atb $wal) $empty
# tell exhcange which one is the CDC token
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb cdc) $(atb $cdc) $empty


# fixed part of fee that is independent of purchase value
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb fixFee) $(etb 0) $empty
# percentage value defining how much of purchase value if paid as fee value between 0 - 1 ether
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb varFee) $(etb 0.03) $empty
# percentage value telling how much of total fee goes to profit of DPT owners
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb profitRate) $(etb 0.1) $empty
# if set true only profit part of fee is withdrawn from user in DPT, if false the total fee will be taken from user in DPT
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb takeProfitOnlyInDpt) $false $empty

# user can buy dpass
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb canBuyErc721) $(atb $dpass) $true
# user can sell dpass
seth send $dex "setConfig(bytes32,bytes32,bytes32)" $(ttb canSellErc721) $(atb $dpass) $true


#----------------------------------------setup-asm------------------------------------------------------------

export domain=$(ttb diamonds)
# set price feed (same as for exchange)
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb priceFeed) $(atb $cdc) $(atb $cdcPriceFeed) $domain
# enable to use rate that is not coming from feed
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb manualRate) $(atb $cdc) $true $domain
# set precision of token to 18
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb decimals) $(atb $cdc) $b18 $domain
# allow cdc to be used as means of payment for services
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb payTokens) $(atb $cdc) $true $domain
# tell asm that cdc is indeed a cdc token
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb cdcs) $(atb $cdc) $true $domain
# set rate for token
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb rate) $(atb $cdc) $(etb 70) $domain


# set price feed (same as for exchange)
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb priceFeed) $(atb $eth) $(atb $ethPriceFeed) $domain
# enable eth to pay with
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb payTokens) $(atb $eth) $true $domain
# enable to set rate of eth manually if feed is dowh (as is current situations)
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb manualRate) $(atb $eth) $true $domain
# set precision of token to 18
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb decimals) $(atb $eth) $b18 $domain
# set USD(base currency) rate of token ( this is the price of token in USD)
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb rate) $(atb $eth) $(etb 146) $domain


# make sure that the value of dpass + dcdc tokens is at least 1.1 times the value of cdc tokens.
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb overCollRatio) $(etb 1.1) $empty $domain
# enable the dpass tokens of asm to be handled by dex
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb dpasses) $(atb $dpass) $true $domain
# enable the dpass tokens of asm to be handled by dex
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb setApproveForAll) $(atb $dpass) $(atb $dex) $true
# setup the custodian
seth send $asm "setConfig(bytes32,bytes32,bytes32,bytes32)" $(ttb custodians) $(atb $custodian) $true $domain

set +x
